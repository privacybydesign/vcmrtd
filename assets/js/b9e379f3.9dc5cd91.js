"use strict";(self.webpackChunkdmrtd_docs=self.webpackChunkdmrtd_docs||[]).push([[6877],{7787:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"info/aa","title":"Active Authentication (AA)","description":"Active Authentication is an optional security protocol aimed at detecting cloning of passport chips. Where Passive Authentication verifies the data, Active Authentication verifies the chip\u2019s uniqueness. It\u2019s essentially a challenge-response protocol using an asymmetric key pair embedded in the passport If a passport supports AA, it will have:","source":"@site/docs/info/aa.md","sourceDirName":"info","slug":"/info/aa","permalink":"/dmrtd/info/aa","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docSidebar","previous":{"title":"Passport Issuance Flows","permalink":"/dmrtd/library/flow"},"next":{"title":"Basic Access Control (BAC)","permalink":"/dmrtd/info/bac"}}');var n=i(4848),a=i(8453);const o={},r="Active Authentication (AA)",h={},c=[];function l(e){const t={code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"active-authentication-aa",children:"Active Authentication (AA)"})}),"\n",(0,n.jsx)(t.p,{children:"Active Authentication is an optional security protocol aimed at detecting cloning of passport chips. Where Passive Authentication verifies the data, Active Authentication verifies the chip\u2019s uniqueness. It\u2019s essentially a challenge-response protocol using an asymmetric key pair embedded in the passport: the chip proves it holds a private key that corresponds to a public key stored in the passport\u2019s data, thereby confirming that this is not just a copy of the data on another chip. How it works: If a passport supports AA, it will have:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"A private key securely stored on the chip (inaccessible for reading)."}),"\n",(0,n.jsx)(t.li,{children:"The corresponding public key stored in Data Group 15 (DG15). DG15 may include the key algorithm info (e.g., RSA 1024-bit or 2048-bit modulus, or an ECC public key point, etc.). The hash of this public key is also included in the EF.SOD signature, meaning any alteration of the key would be detected by Passive Auth."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"During inspection, after BAC (so the communication is secure), the reader may perform Active Authentication as follows:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"The terminal reads DG15 to obtain the chip\u2019s public key (let\u2019s call it Pub_AA)."}),"\n",(0,n.jsx)(t.li,{children:"The terminal generates a random challenge (usually 8 bytes as per the standard). It sends this challenge to the chip in an INTERNAL AUTHENTICATE APDU."}),"\n",(0,n.jsxs)(t.li,{children:["The chip, upon receiving the challenge, may also generate its own random (some implementations do this to ensure it\u2019s not replayable). According to ICAO 9303, the chip could concatenate its own random R",(0,n.jsx)("sub",{children:"ICC"})," with the terminal\u2019s challenge R",(0,n.jsx)("sub",{children:"IFD"}),", and perhaps hash them, then sign the result with its private key. (One common method: the chip signs R",(0,n.jsx)("sub",{children:"IFD"})," || R",(0,n.jsx)("sub",{children:"ICC"})," or a hash thereof.)"]}),"\n",(0,n.jsx)(t.li,{children:"The chip returns the signature (and possibly its random if used) to the terminal."}),"\n",(0,n.jsx)(t.li,{children:"The terminal verifies the signature using the public key from DG15. If the signature is correct, it proves the chip had the matching private key, meaning this chip is the genuine one originally issued with that passport\u2019s data."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"If an attacker only cloned the data onto another chip, they would not have the original chip\u2019s private key, so they would fail to produce a valid signature in step 5. Thus, AA is effective against cloning attacks where someone tries to use a copied data (since Passive Auth would still pass on a clone, AA adds an extra check)."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Algorithm and standards"}),": The challenge-response in AA is based on ISO 9796-2 (for RSA) or analogous for ECDSA. Many passports historically used RSA keys (1024-bit) for AA. Newer ones might use ECC (with smaller key sizes but strong security). The protocol is simple: sign a nonce. It\u2019s important that the nonce be unique per session (terminal ensures that by generating random, chip often adds its own random too). Also, to avoid replay, the chip\u2019s random or the fact that the challenge is different ensures an attacker can\u2019t replay a known signature."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Privacy consideration"}),': Active Authentication does have a privacy implication: the chip\u2019s public key is static and unique per passport. If an attacker could trigger AA and get a signature, in theory they could identify the passport by that signature (since the public key acts like an ID). A known attack is that if someone could query a passport at two different places, they could confirm it\u2019s the same passport by checking the public key or verifying a signature with a previously seen public key. This is mitigated by the need to do BAC first (so random people can\u2019t do AA without MRZ), but BAC keys can sometimes be guessed or the attacker might be an insider. Germany and some other countries considered this a "privacy threat" \u2013 the scenario described by Riha is that an inspection system could craft a challenge that encodes location/time, and later show the signed challenge as proof that a passport was present at that place/time (non-repudiation issue). Because of such concerns, Germany, and others (Greece, Italy, France) chose not to implement Active Authentication in their e-passports. They instead relied on the later Chip Authentication as part of EAC for anti-cloning (which is done under secure messaging and doesn\u2019t reveal a static public key to eavesdroppers, thereby avoiding the traceability issue).']}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Active Auth vs. Chip Auth"}),": Active Authentication was the first-gen solution to cloning. Chip Authentication (in EAC) can be seen as a replacement in newer passports (it achieves the same goal but in a more sophisticated way). Indeed, Chip Auth subsumes AA\u2019s role and also sets up new session keys, removing the traceability problem. Many passports that implement EAC skip AA. Some implement both (to remain compatible or add redundancy)."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"When/How it\u2019s run"}),": Typically, if AA is supported, the inspection system will do it right after BAC and before reading too many files (or at least before concluding the session). For example, an order might be: BAC -> read DG1/DG2 -> do AA -> then proceed. It doesn\u2019t strictly have to be before reading, but since AA doesn\u2019t require reading any more files (just uses DG15), it\u2019s efficient to do it early. Doing it after reading doesn\u2019t add benefit because if a clone was present, all data read was from clone already. Some systems might even do AA after reading to cross-check, but logically sooner is better."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Cloning and relay"}),": Note that AA can be defeated by a relay attack: An attacker with a cloned chip could secretly communicate with the genuine passport in the victim\u2019s pocket over some channel (like using two radio devices). The clone, when asked to do AA, relays the challenge to the genuine passport (which is perhaps close by) and relays back the signature. This way the clone chip itself doesn\u2019t need the private key; it just \u201casks\u201d the real one over the air. This is a man-in-the-middle attack and has been demonstrated (known as the \u201cghost and leech\u201d attack). Such an attack is high-tech and requires the genuine passport to be in range (and BAC keys known, etc.), but it\u2019s theoretically possible. It shows that even AA isn\u2019t foolproof if someone can proxy the communication (which BAC was supposed to prevent by requiring physical proximity to see MRZ, but if the attacker has that, they might as well just steal the passport outright!). Nonetheless, it\u2019s a noted vulnerability in research."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Library implementation"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"final passport = Passport(_nfc);\r\n// Assuming you have a passport object with methods to read DG15 and perform AA\r\n\r\n// Read the public key from DG15\r\nfinal dg15 = await passport.readEfDG15();\r\n\r\n// Perform Active Authentication note the challenge size is typically 8 bytes\r\nfinal aaSig = await passport.activeAuthenticate(Uint8List(8));\n"})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}}}]);